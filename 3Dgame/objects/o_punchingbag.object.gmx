<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>s_playercol</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>parent_enemy</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>tex=sprite_get_texture(s_face,0);

z=0;
dir_face=0;
target_dir_face=0;

state=0;
    // 0 = def
    // 1 = attack
    // 2 = hit
    // 3 = dead
    
movedir=-1;
lean=0;

hp=100;

//hit
cooldown=0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string> if !control.pause{

if state!=3 lean=lerp(lean,0,1/(room_speed/12));

if state==0{ //normal movement
    // face player
    if distance_to_object(o_player)&lt;192 dir_face=point_direction(x,y,o_player.x,o_player.y);
    // detect if hit
    if distance_to_object(o_player)&lt;32 and state==0{ 
        if o_player.state==1{
            if collision_circle(o_player.x+lengthdir_x(16,o_player.facedir),o_player.y+lengthdir_y(16,o_player.facedir),16,self,false,false){
                hp-=10;
                lean=0;
                if hp&lt;=0 {state=3; lean=45; movedist=4;}
                else {state=2; lean=30; movedist=2;}
                movedir=point_direction(o_player.x,o_player.y,x,y);
            }
        }
    }
}
else if state==2{ //hit
    cooldown++;
    if cooldown&gt;(room_speed/4){ // If the hit animation has played for 1/4 second
        movedir=-1;
        state=0;
        cooldown=0;
        movedist=0;
    }
}
if state==3{ //dead
    cooldown++;
    if cooldown&gt;(room_speed/2){ // If the hit animation has played for 1/2 second
        instance_destroy();
    }
    else{
        image_alpha-=(2/room_speed);
        lean=lerp(lean,90,1/(room_speed/2));
    }
}

//Collision Checking
if (movedir!=-1){
    
    var dist = lerp(movedist,0,(cooldown/(room_speed/(6-movedist))));
    //x+=lengthdir_x(dist,movedir);
    //y+=lengthdir_y(dist,movedir);
                                
    if lengthdir_y(1,movedir)!=0 {
        if collision_rectangle(x-8,y-8+lengthdir_y(dist,movedir),x+8,y+8+lengthdir_y(dist,movedir),parent_solid,false,true) or collision_rectangle(x-8,y-8+lengthdir_y(dist,movedir),x+8,y+8+lengthdir_y(dist,movedir),o_player,false,true) {
            if lengthdir_y(1,movedir)&gt;0 {
                while (!collision_rectangle(x-8,y-7,x+8,y+9,parent_solid,false,true) and !collision_rectangle(x-8,y-7,x+8,y+9,o_player,false,true)){ 
                    y++;
                }
            }
            else if lengthdir_y(1,movedir)&lt;0 {
                while(!collision_rectangle(x-8,y-9,x+8,y+7,parent_solid,false,true) and !collision_rectangle(x-8,y-9,x+8,y+7,o_player,false,true)){
                    y--;
                }
            }
        }
        else y+=lengthdir_y(dist,movedir);
    }
    
    if lengthdir_x(1,movedir)!=0 {
        if collision_rectangle(x-8+lengthdir_x(dist,movedir),y-8,x+8+lengthdir_x(dist,movedir),y+8,parent_solid,false,true) or collision_rectangle(x-8+lengthdir_x(dist,movedir),y-8,x+8+lengthdir_x(dist,movedir),y+8,o_player,false,true) {
            if lengthdir_x(1,movedir)&gt;0 {
                while (!collision_rectangle(x-7,y-8,x+9,y+8,parent_solid,false,true) and !collision_rectangle(x-7,y-8,x+9,y+8,o_player,false,true)){ 
                    x++;
                }
            }
            else if lengthdir_x(1,movedir)&lt;0 {
                while(!collision_rectangle(x-9,y-8,x+7,y+8,parent_solid,false,true) and !collision_rectangle(x-9,y-8,x+7,y+8,o_player,false,true)){
                    x--;
                }
            }
        }
        else x+=lengthdir_x(dist,movedir);
    }                                    
}

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>d3d_transform_set_identity();

d3d_transform_add_rotation_y(lean);

if state==3 draw_set_alpha(image_alpha);

d3d_transform_add_rotation_z(dir_face);
d3d_transform_add_translation(x, y, z);

texture_set_interpolation(0);
texture_set_repeat(0);

d3d_model_draw(global.model_punchingbag,0,0,0,tex);

if state==3 draw_set_alpha(1);

d3d_transform_set_identity();

if state!=3{
    d3d_transform_add_rotation_x(90);
    d3d_transform_add_rotation_z(point_direction(x, y, o_camera.x,o_camera.y)+90);
    d3d_transform_add_translation(x, y, z+48);
    
    draw_set_color(c_black);
    draw_rectangle(-8,0,8,2,false);
    
    draw_set_color(make_color_rgb(255*(clamp(abs((hp/50)-2),0,1)),255*(clamp(hp/50,0,1)),0));
    
    d3d_transform_add_translation(lengthdir_x(1,o_camera.yaw), lengthdir_y(1,o_camera.yaw), 0);
    
    draw_rectangle(-8,0,(16*(hp/100))-8,2,false);
    
    draw_set_color(c_white);
    d3d_transform_set_identity();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
