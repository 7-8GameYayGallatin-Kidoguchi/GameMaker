<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>s_playercol</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>parent_enemy</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>tex=sprite_get_texture(s_face,2);

z=0;
dir_face=0;

state=0;
    // 0 - normal movement
    // 1 - attack
    // 2 - hit
    // 3 - dead
movedir=-1;
disttime=0;
distmove=0;

mppath=path_add();

lean=0;

hp=100;

//hit
cooldown=0;
//attack
windup=0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if path_exists(mppath) path_delete(mppath);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string> if !control.pause{

var canSee=!collision_line(x,y,o_player.x,o_player.y,parent_solid_pathfinding,false,true);
show_debug_message(collision_line(x,y,o_player.x,o_player.y,parent_solid_pathfinding,false,true));
if keyboard_check(vk_backspace) {
    if instance_exists(collision_line(x,y,o_player.x,o_player.y,parent_solid_pathfinding,false,true)) 
    with (collision_line(x,y,o_player.x,o_player.y,parent_solid_pathfinding,false,true)) { instance_destroy(); }
}
 
if state!=3 { //if not dead
    lean=lerp(lean,0,1/(room_speed/12));
}

if state==0{ //normal movement
    // detect if hit
    if distance_to_object(o_player)&lt;=64{
        if o_player.state==1{
            if collision_circle(o_player.x+lengthdir_x(16,o_player.facedir),o_player.y+lengthdir_y(16,o_player.facedir),16,self,false,false){ //If the enemy got hit
                hp-=10;
                lean=0;
                if hp&lt;=0 {state=3; lean=45; movedist=4; movetime=4;}
                else {state=2; lean=30; movedist=2;movetime=2;}
                movedir=point_direction(o_player.x,o_player.y,x,y);
            }
        }
        if state==0 { //If the enemy didn't get hit
            movedir=-1; //Stop pathfinding
            movedist=0;
                
            windup++;
            if windup&gt;(room_speed*2){
                state=1; lean=-30; movedist=4; movetime=2; //attacking
            }
        }
    }
    else { //Player out of range and behind a solid   //if distance_to_object(o_player)&gt;64{
        windup=0;
        lean=-1;
        movedir=point_direction(x,y,o_player.x,o_player.y);
        movedist=1.5; movetime=1.5;
    }
    
    // face player
    if canSee dir_face=point_direction(x,y,o_player.x,o_player.y);
    else if movedir!=-1 dir_face=movedir;
    //else if movetype=1 dir_face=point_direction(x,y,path_get_x(mppath,1),path_get_y(mppath,1));
    
}
else if state==1{ //attack
    movedir=point_direction(x,y,o_player.x,o_player.y);
}
else if state==2{ //hit
}
if state==3{ //dead
    windup=0;
    
    cooldown++;
    if cooldown&gt;(room_speed/movetime){ // If the hit animation has played for 1/2 second
        instance_destroy();
    }
    else{
        image_alpha-=(2/room_speed);
        lean=lerp(lean,90,1/(room_speed/2));
    }
}

//Collision Checking
if (movedir!=-1){

    if state==1 or state==2{
        windup=0;
    
        cooldown++;
        if cooldown&gt;(room_speed/(6-movetime)){ // If the attack animation has played for 1/movetime second
            movedir=-1;
            state=0;
            cooldown=0;
            movedist=0;
        }
    }

    var dist = lerp(movedist,0,(cooldown/(room_speed/(6-movetime))));
    //x+=lengthdir_x(dist,movedir);
    //y+=lengthdir_y(dist,movedir);
                                
    if lengthdir_y(1,movedir)!=0 {
        if collision_rectangle(x-8,y-8+lengthdir_y(dist,movedir),x+8,y+8+lengthdir_y(dist,movedir),parent_solid,false,true) or collision_rectangle(x-8,y-8+lengthdir_y(dist,movedir),x+8,y+8+lengthdir_y(dist,movedir),o_player,false,true) {
            if lengthdir_y(1,movedir)&gt;0 {
                while (!collision_rectangle(x-8,y-7,x+8,y+9,parent_solid,false,true) and !collision_rectangle(x-8,y-7,x+8,y+9,o_player,false,true)){ 
                    y++;
                }
            }
            else if lengthdir_y(1,movedir)&lt;0 {
                while(!collision_rectangle(x-8,y-9,x+8,y+7,parent_solid,false,true) and !collision_rectangle(x-8,y-9,x+8,y+7,o_player,false,true)){
                    y--;
                }
            }
        }
        else y+=lengthdir_y(dist,movedir);
    }
    
    if lengthdir_x(1,movedir)!=0 {
        if collision_rectangle(x-8+lengthdir_x(dist,movedir),y-8,x+8+lengthdir_x(dist,movedir),y+8,parent_solid,false,true) or collision_rectangle(x-8+lengthdir_x(dist,movedir),y-8,x+8+lengthdir_x(dist,movedir),y+8,o_player,false,true) {
            if lengthdir_x(1,movedir)&gt;0 {
                while (!collision_rectangle(x-7,y-8,x+9,y+8,parent_solid,false,true) and !collision_rectangle(x-7,y-8,x+9,y+8,o_player,false,true)){ 
                    x++;
                }
            }
            else if lengthdir_x(1,movedir)&lt;0 {
                while(!collision_rectangle(x-9,y-8,x+7,y+8,parent_solid,false,true) and !collision_rectangle(x-9,y-8,x+7,y+8,o_player,false,true)){
                    x--;
                }
            }
        }
        else x+=lengthdir_x(dist,movedir);
    }                                    
}

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if path_exists(mppath) path_delete(mppath);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>d3d_transform_set_identity();

if state==3 {draw_set_alpha(image_alpha);}

d3d_transform_add_rotation_y(lean);

d3d_transform_add_rotation_z(dir_face);
d3d_transform_add_translation(x, y, z);

texture_set_interpolation(0);
texture_set_repeat(0);

d3d_model_draw(global.model_punchingbag,0,0,0,tex);

if state==3 draw_set_alpha(1);

d3d_transform_set_identity();

if state!=3{
    d3d_transform_add_rotation_x(90);
    d3d_transform_add_rotation_z(point_direction(x, y, o_camera.x,o_camera.y)+90);
    d3d_transform_add_translation(x, y, z+48);
    
    draw_set_color(c_black);
    draw_rectangle(-8,0,8,2,false); //Healthbar underlay
    
    draw_set_color(make_color_rgb(255*(clamp(abs((hp/50)-2),0,1)),255*(clamp(hp/50,0,1)),0));
    
    d3d_transform_add_translation(lengthdir_x(1,o_camera.yaw), lengthdir_y(1,o_camera.yaw), 0);
    
    draw_rectangle(-8,0,(16*(hp/100))-8,2,false); //Health
    
    d3d_transform_add_translation(0,0,-8);
    draw_set_color(c_white);
    
    draw_rectangle(-8,0,(16*(windup/(room_speed*2)))-8,2,false); //Windup
    
    d3d_transform_set_identity();
    
    if state==1 draw_set_color(c_red);
    d3d_transform_add_translation(0, 0, 1);
    draw_set_color(c_white);
    if collision_line(x,y,o_player.x,o_player.y,parent_solid_pathfinding,true,true) draw_set_color(c_red);
    draw_line(x,y,o_player.x,o_player.y);
    draw_set_color(c_white);
    draw_path(mppath,x,y,false);
    d3d_transform_add_translation(x, y, z);
    draw_circle(lengthdir_x(16,dir_face),lengthdir_y(16,dir_face),32,true);    
    d3d_transform_set_identity();
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
