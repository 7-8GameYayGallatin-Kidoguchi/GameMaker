<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>s_playercol</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>parent_enemy</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>tex=sprite_get_texture(s_face,2);

z=0;
dir_face=0;
target_dir_face=0;

state=0;
    // 0 - normal movement
    // 1 - attack
    // 2 - hit
    // 3 - dead
movedir=-1;
lean=0;

hp=100;

//hit
cooldown=0;
//attack
windup=0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string> if !control.pause{

if state!=3{ // If not dead
    lean=lerp(lean,0,1/(room_speed/12));
    
    if windup&gt;room_speed{
    state=1; lean=-30; //attacking
    }
}

if state==3{ // If state is dying
    cooldown++;
    if cooldown&gt;(room_speed/2){
        instance_destroy();
    }
    else{
        var dist = lerp(4,0,(cooldown/(room_speed/2)));
        x+=lengthdir_x(dist,movedir);
        y+=lengthdir_y(dist,movedir);
        image_alpha-=(2/room_speed);
        lean=lerp(lean,90,1/(room_speed/2));
    }
   
}
else if state==2{ //If state is hit
    windup=0;
    
}
else if state==1{ // If state is attacking
    windup=0;

    cooldown++;
    if cooldown&gt;(room_speed/4){
        movedir=-1;
        state=0;
        cooldown=0;
    }
    else{
        var dist = lerp(2,0,(cooldown/(room_speed/4)));
        x+=lengthdir_x(dist,movedir);
        y+=lengthdir_y(dist,movedir);
    } 
}
else if state==0{ // If state is normal movement
    if distance_to_object(o_player)&lt;192 dir_face=point_direction(x,y,o_player.x,o_player.y);
    if distance_to_object(o_player)&lt;32 and state==0{ 
    if o_player.state==1{
        if collision_circle(o_player.x+lengthdir_x(16,o_player.facedir),o_player.y+lengthdir_y(16,o_player.facedir),16,self,false,false){
            hp-=10; windup=0;
            if hp&lt;=0 { state=3; lean=45;}
            else { state=2; lean=30;}
            movedir=point_direction(o_player.x,o_player.y,x,y);
        }
    }
}
}
}

/*if distance_to_object(o_player)&lt;192{

var target_turn = dir_face;

temptarget=point_direction(x,y,o_player.x,o_player.y);
if ((abs(temptarget-dir_face)) &lt;= (abs(dir_face-temptarget))){
    target_turn = (temptarget-dir_face);
}
else if ((abs(temptarget-dir_face)) &gt; (abs(dir_face-temptarget))){
    target_turn = (dir_face-temptarget);
}

//dir_face=0;
}

dir_face=lerp(dir_face,(dir_face-target_turn),.05)%360;*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>d3d_transform_set_identity();

if state==3 {draw_set_alpha(image_alpha);}

d3d_transform_add_rotation_y(lean);

d3d_transform_add_rotation_z(dir_face);
d3d_transform_add_translation(x, y, z);

texture_set_interpolation(0);
texture_set_repeat(0);

d3d_model_draw(global.model_punchingbag,0,0,0,tex);

if state==3 draw_set_alpha(1);

d3d_transform_set_identity();

if state!=3{
    d3d_transform_add_rotation_x(90);
    d3d_transform_add_rotation_z(point_direction(x, y, o_camera.x,o_camera.y)+90);
    d3d_transform_add_translation(x, y, z+48);
    
    draw_set_color(c_black);
    draw_rectangle(-8,0,8,2,false);
    
    draw_set_color(make_color_rgb(255*(clamp(abs((hp/50)-2),0,1)),255*(clamp(hp/50,0,1)),0));
    
    d3d_transform_add_translation(lengthdir_x(1,o_camera.dir_face), lengthdir_y(1,o_camera.dir_face), 0);
    
    draw_rectangle(-8,0,(16*(hp/100))-8,2,false);
    
    draw_set_color(c_white);
    d3d_transform_set_identity();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
